"""
Unified Trading Strategy Backtesting Framework

Compare all models (Heston, SABR, Local Vol, Multi-Agent) on trading performance
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import logging

from models.heston import HestonModel
from models.sabr import SABRModel
from models.local_volatility import LocalVolatilityModel
from models.model_calibrator import ModelCalibrator
from risk.delta_hedging import DeltaHedger, Position

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@dataclass
class TradingSignal:
    """Trading signal generated by model"""
    timestamp: pd.Timestamp
    instrument_id: str
    strike: float
    expiry: float
    option_type: str
    signal_type: str  # 'buy', 'sell', 'hold'
    model_price: float
    market_price: float
    expected_edge: float  # Model price - Market price
    confidence: float = 0.5
    quantity: float = 1.0


@dataclass
class Trade:
    """Executed trade"""
    timestamp: pd.Timestamp
    instrument_id: str
    side: str  # 'buy' or 'sell'
    quantity: float
    price: float
    transaction_cost: float
    position_delta: float
    position_gamma: float
    position_vega: float


@dataclass
class BacktestResult:
    """Backtesting results for a single model"""
    model_name: str
    trades: List[Trade] = field(default_factory=list)
    pnl_series: pd.Series = field(default_factory=pd.Series)
    hedge_history: pd.DataFrame = field(default_factory=pd.DataFrame)

    # Performance metrics
    total_pnl: float = 0.0
    gross_pnl: float = 0.0
    net_pnl: float = 0.0
    transaction_costs: float = 0.0
    hedge_costs: float = 0.0
    sharpe_ratio: float = 0.0
    max_drawdown: float = 0.0
    win_rate: float = 0.0
    num_trades: int = 0

    # Risk metrics
    var_95: float = 0.0
    cvar_95: float = 0.0
    max_delta_exposure: float = 0.0
    final_delta: float = 0.0


class ModelTradingStrategy:
    """
    Trading strategy for a single model
    """

    def __init__(self,
                 model_name: str,
                 calibrated_params: Dict,
                 spot_price: float,
                 risk_free_rate: float,
                 transaction_cost: float = 0.0005,
                 edge_threshold: float = 0.02):
        """
        Initialize model trading strategy

        Parameters:
        -----------
        model_name : str
            Model name: 'heston', 'sabr', 'local_volatility', 'multi_agent'
        calibrated_params : dict
            Calibrated model parameters
        spot_price : float
            Current spot price
        risk_free_rate : float
            Risk-free rate
        transaction_cost : float
            Transaction cost (fraction of trade value)
        edge_threshold : float
            Minimum edge required to trade (e.g., 2%)
        """
        self.model_name = model_name
        self.calibrated_params = calibrated_params
        self.spot_price = spot_price
        self.risk_free_rate = risk_free_rate
        self.transaction_cost = transaction_cost
        self.edge_threshold = edge_threshold

        # Initialize delta hedger
        self.delta_hedger = DeltaHedger(
            transaction_cost=transaction_cost,
            hedge_threshold=0.1
        )

        self.trades: List[Trade] = []
        self.pnl_history: List[Dict] = []

    def compute_model_price(self, option: Dict) -> Tuple[float, Dict]:
        """
        Compute model price for an option

        Parameters:
        -----------
        option : dict
            Option details (strike, expiry, option_type, etc.)

        Returns:
        --------
        tuple : (model_price, greeks)
        """
        K = option['strike']
        T = option['years_to_expiry']
        option_type = option['option_type']

        # Validate time to expiry
        if T <= 0:
            raise ValueError(f"Invalid time to expiry: {T}. Option may have expired.")

        if self.model_name == 'heston':
            from models.heston import HestonParameters
            # Ensure we use 'xi' key, handling both 'xi' and 'sigma_v' from calibration
            xi_value = self.calibrated_params.get('xi', self.calibrated_params.get('sigma_v', 0.3))

            params = HestonParameters(
                S0=self.spot_price,
                K=K,
                T=T,
                r=self.risk_free_rate,
                q=0.0,
                v0=self.calibrated_params['v0'],
                kappa=self.calibrated_params['kappa'],
                theta=self.calibrated_params['theta'],
                xi=xi_value,
                rho=self.calibrated_params['rho']
            )
            model = HestonModel(params)
            price = model.option_price(option_type=option_type)
            greeks = model.greeks(option_type=option_type)

        elif self.model_name == 'sabr':
            F = self.spot_price * np.exp(self.risk_free_rate * T)
            model = SABRModel(
                F=F,
                K=K,
                T=T,
                r=self.risk_free_rate,
                alpha=self.calibrated_params['alpha'],
                beta=self.calibrated_params['beta'],
                rho=self.calibrated_params['rho'],
                nu=self.calibrated_params['nu']
            )
            price = model.price(option_type=option_type)
            greeks = model.greeks(option_type=option_type)

        elif self.model_name == 'local_volatility':
            model = self.calibrated_params['model']
            price = model.price(K, T, option_type=option_type)
            greeks = model.greeks(K, T, option_type=option_type)

        elif self.model_name == 'multi_agent':
            framework = self.calibrated_params['framework']
            # Use Q* measure price with compute_expectation
            # Define payoff function for the option
            if option_type == 'call':
                payoff_function = lambda S: max(S - K, 0)
            else:  # put
                payoff_function = lambda S: max(K - S, 0)

            # Compute option price using Q* measure expectation
            price = framework.Q_star_measure.compute_expectation(
                payoff_function, self.spot_price, T
            )
            # Approximate greeks
            greeks = self._approximate_greeks(price, K, T, option_type)

        else:
            raise ValueError(f"Unknown model: {self.model_name}")

        return price, greeks

    def _approximate_greeks(self, price: float, K: float, T: float,
                          option_type: str) -> Dict[str, float]:
        """Approximate Greeks using finite difference"""
        epsilon_S = 0.01 * self.spot_price
        epsilon_T = 1.0 / 365.0

        # Delta (simplified)
        delta = 0.5 if abs(self.spot_price - K) < 0.1 * K else \
                (1.0 if self.spot_price > K else 0.0)

        return {
            'delta': delta if option_type == 'call' else delta - 1,
            'gamma': 0.01,
            'vega': 0.1,
            'theta': -0.01
        }

    def generate_signal(self, option: Dict, market_price: float) -> Optional[TradingSignal]:
        """
        Generate trading signal based on model vs market price

        Parameters:
        -----------
        option : dict
            Option details
        market_price : float
            Current market price

        Returns:
        --------
        TradingSignal or None : Trading signal if edge exceeds threshold
        """
        # Skip options with invalid expiry
        if option.get('years_to_expiry', 0) <= 0:
            return None

        model_price, greeks = self.compute_model_price(option)

        # Calculate edge
        edge = model_price - market_price
        edge_pct = edge / market_price if market_price > 0 else 0

        # Generate signal
        if abs(edge_pct) < self.edge_threshold:
            return None  # No signal - edge too small

        signal_type = 'buy' if edge > 0 else 'sell'  # Buy if underpriced

        signal = TradingSignal(
            timestamp=pd.Timestamp.now(),
            instrument_id=f"{option['strike']}-{option['expiration']}-{option['option_type']}",
            strike=option['strike'],
            expiry=option['years_to_expiry'],
            option_type=option['option_type'],
            signal_type=signal_type,
            model_price=model_price,
            market_price=market_price,
            expected_edge=edge,
            confidence=min(abs(edge_pct) / 0.1, 1.0),  # Confidence based on edge size
            quantity=1.0
        )

        return signal

    def execute_signal(self, signal: TradingSignal, timestamp: pd.Timestamp) -> Trade:
        """
        Execute a trading signal

        Parameters:
        -----------
        signal : TradingSignal
            Signal to execute
        timestamp : pd.Timestamp
            Execution timestamp

        Returns:
        --------
        Trade : Executed trade
        """
        # Determine trade side and price
        side = signal.signal_type
        price = signal.market_price
        quantity = signal.quantity if side == 'buy' else -signal.quantity

        # Calculate transaction cost
        trade_value = abs(quantity * price)
        cost = trade_value * self.transaction_cost

        # Get greeks
        _, greeks = self.compute_model_price({
            'strike': signal.strike,
            'years_to_expiry': signal.expiry,
            'option_type': signal.option_type
        })

        trade = Trade(
            timestamp=timestamp,
            instrument_id=signal.instrument_id,
            side=side,
            quantity=quantity,
            price=price,
            transaction_cost=cost,
            position_delta=quantity * greeks['delta'],
            position_gamma=quantity * greeks['gamma'],
            position_vega=quantity * greeks['vega']
        )

        self.trades.append(trade)

        # Add to delta hedger
        position = Position(
            instrument_id=signal.instrument_id,
            position_type='option',
            quantity=quantity,
            entry_price=price,
            current_price=price,
            delta=greeks['delta'],
            gamma=greeks['gamma'],
            vega=greeks['vega'],
            theta=greeks['theta']
        )

        self.delta_hedger.add_option_position(position)

        logger.info(
            f"{self.model_name}: {side.upper()} {abs(quantity):.2f} @ {price:.2f}, "
            f"Edge: {signal.expected_edge:.4f}"
        )

        return trade

    def update_and_hedge(self, timestamp: pd.Timestamp, underlying_price: float):
        """
        Update positions and execute delta hedging

        Parameters:
        -----------
        timestamp : pd.Timestamp
            Current timestamp
        underlying_price : float
            Current underlying price
        """
        self.spot_price = underlying_price

        # Update all position prices and greeks
        new_prices = {}
        new_greeks = {}

        for pos in self.delta_hedger.option_positions:
            # Recompute prices and greeks
            option_info = self._parse_instrument_id(pos.instrument_id)

            # Skip expired options
            if option_info.get('years_to_expiry', 0) <= 0:
                continue

            try:
                model_price, greeks = self.compute_model_price(option_info)
                new_prices[pos.instrument_id] = model_price
                new_greeks[pos.instrument_id] = greeks
            except:
                continue

        self.delta_hedger.update_positions(new_prices, new_greeks)

        # Execute delta hedging
        self.delta_hedger.execute_hedge(timestamp, underlying_price)

        # Record P&L
        pnl = self.delta_hedger.calculate_pnl(underlying_price)
        self.pnl_history.append({
            'timestamp': timestamp,
            **pnl
        })

    def _parse_instrument_id(self, instrument_id: str) -> Dict:
        """Parse instrument ID back to option details"""
        parts = instrument_id.split('-')
        expiration_str = parts[1]

        # Handle both formats: synthetic (e.g., '7D') and real Deribit (e.g., '16OCT25')
        if expiration_str.endswith('D'):
            # Synthetic format: {days}D
            days_to_expiry = float(expiration_str.replace('D', ''))
            years_to_expiry = days_to_expiry / 365.0
        else:
            # Real Deribit format: DDMMMYY (e.g., '16OCT25')
            try:
                expiration_date = pd.to_datetime(expiration_str, format='%d%b%y')
                days_to_expiry = (expiration_date - pd.Timestamp.now()).days
                years_to_expiry = max(days_to_expiry / 365.0, 0.0)  # Ensure non-negative
            except Exception as e:
                # Fallback if parsing fails
                logger.warning(f"Could not parse expiration date '{expiration_str}': {e}")
                years_to_expiry = 0.0

        return {
            'strike': float(parts[0]),
            'years_to_expiry': years_to_expiry,
            'option_type': parts[2],
            'expiration': expiration_str
        }

    def get_performance_metrics(self) -> Dict:
        """
        Calculate strategy performance metrics

        Returns:
        --------
        dict : Performance metrics
        """
        if not self.pnl_history:
            return {}

        pnl_df = pd.DataFrame(self.pnl_history)

        # Total P&L
        total_pnl = pnl_df['net_pnl'].iloc[-1] if len(pnl_df) > 0 else 0.0
        gross_pnl = pnl_df['gross_pnl'].iloc[-1] if len(pnl_df) > 0 else 0.0

        # Sharpe ratio (annualized)
        returns = pnl_df['net_pnl'].diff().dropna()
        if len(returns) > 1 and returns.std() > 0:
            sharpe = np.sqrt(252) * returns.mean() / returns.std()
        else:
            sharpe = 0.0

        # Max drawdown
        cumulative = pnl_df['net_pnl'].cumsum()
        running_max = cumulative.expanding().max()
        drawdown = cumulative - running_max
        max_dd = drawdown.min()

        # Win rate
        winning_trades = sum(1 for t in self.trades if t.side == 'buy')
        win_rate = winning_trades / len(self.trades) if self.trades else 0.0

        # Transaction costs
        total_costs = sum(t.transaction_cost for t in self.trades)
        hedge_costs = self.delta_hedger.cumulative_hedge_cost

        # Risk metrics
        var_95 = np.percentile(returns, 5) if len(returns) > 0 else 0.0

        return {
            'total_pnl': total_pnl,
            'gross_pnl': gross_pnl,
            'net_pnl': total_pnl,
            'transaction_costs': total_costs,
            'hedge_costs': hedge_costs,
            'sharpe_ratio': sharpe,
            'max_drawdown': max_dd,
            'win_rate': win_rate * 100,
            'num_trades': len(self.trades),
            'var_95': var_95,
            'final_delta': self.delta_hedger.get_portfolio_delta()
        }


class ModelComparisonBacktest:
    """
    Compare multiple models on the same backtest data
    """

    def __init__(self,
                 market_data: pd.DataFrame,
                 spot_price: float,
                 risk_free_rate: float,
                 calibrator: ModelCalibrator):
        """
        Initialize model comparison backtest

        Parameters:
        -----------
        market_data : pd.DataFrame
            Market option data over time
        spot_price : float
            Initial spot price
        risk_free_rate : float
            Risk-free rate
        calibrator : ModelCalibrator
            Calibrated models
        """
        # Filter out expired or invalid options upfront
        if 'years_to_expiry' in market_data.columns:
            valid_data = market_data[market_data['years_to_expiry'] > 0].copy()

            if len(valid_data) < len(market_data):
                logger.warning(
                    f"Filtered out {len(market_data) - len(valid_data)} expired/invalid options. "
                    f"Remaining: {len(valid_data)} options"
                )
            self.market_data = valid_data
        else:
            logger.warning("'years_to_expiry' column not found in market_data. Skipping validation.")
            self.market_data = market_data
        self.spot_price = spot_price
        self.risk_free_rate = risk_free_rate
        self.calibrator = calibrator

        self.strategies: Dict[str, ModelTradingStrategy] = {}
        self.results: Dict[str, BacktestResult] = {}

    def initialize_strategies(self, model_names: List[str]):
        """
        Initialize trading strategies for each model

        Parameters:
        -----------
        model_names : list
            List of model names to backtest
        """
        for model_name in model_names:
            calibrated_params = self.calibrator.get_calibrated_model(model_name)

            if calibrated_params is None:
                logger.warning(f"Model {model_name} not calibrated. Skipping.")
                continue

            strategy = ModelTradingStrategy(
                model_name=model_name,
                calibrated_params=calibrated_params,
                spot_price=self.spot_price,
                risk_free_rate=self.risk_free_rate
            )

            self.strategies[model_name] = strategy

        logger.info(f"Initialized {len(self.strategies)} strategies")

    def run_backtest(self, start_date: Optional[pd.Timestamp] = None,
                    end_date: Optional[pd.Timestamp] = None):
        """
        Run backtest across all models

        Parameters:
        -----------
        start_date : pd.Timestamp, optional
            Backtest start date
        end_date : pd.Timestamp, optional
            Backtest end date
        """
        logger.info("=" * 60)
        logger.info("Starting Model Comparison Backtest")
        logger.info("=" * 60)

        # Group data by timestamp
        timestamps = self.market_data['timestamp'].unique()

        if start_date:
            timestamps = timestamps[timestamps >= start_date]
        if end_date:
            timestamps = timestamps[timestamps <= end_date]

        for timestamp in timestamps:
            snapshot = self.market_data[self.market_data['timestamp'] == timestamp]

            current_spot = snapshot['underlying_price'].iloc[0]

            # Generate and execute signals for each model
            for model_name, strategy in self.strategies.items():
                for _, option in snapshot.iterrows():
                    # Skip expired or invalid options
                    if option.get('years_to_expiry', 0) <= 0:
                        continue

                    # Generate signal
                    signal = strategy.generate_signal(
                        option.to_dict(),
                        option['mark_price']
                    )

                    if signal:
                        # Execute trade
                        strategy.execute_signal(signal, timestamp)

                # Update positions and hedge
                strategy.update_and_hedge(timestamp, current_spot)

        logger.info("Backtest complete. Computing results...")

        # Compute results for each model
        for model_name, strategy in self.strategies.items():
            metrics = strategy.get_performance_metrics()

            result = BacktestResult(
                model_name=model_name,
                trades=strategy.trades,
                pnl_series=pd.DataFrame(strategy.pnl_history)['net_pnl'],
                hedge_history=strategy.delta_hedger.get_hedge_history_df(),
                **metrics
            )

            self.results[model_name] = result

        logger.info("=" * 60)
        logger.info("Backtest Results Summary")
        logger.info("=" * 60)

        self.print_comparison_summary()

    def print_comparison_summary(self):
        """Print comparison summary of all models"""
        summary_data = []

        for model_name, result in self.results.items():
            summary_data.append({
                'Model': model_name.upper(),
                'Total P&L': f"${result.total_pnl:.2f}",
                'Sharpe Ratio': f"{result.sharpe_ratio:.2f}",
                'Max Drawdown': f"${result.max_drawdown:.2f}",
                'Win Rate': f"{result.win_rate:.1f}%",
                'Num Trades': result.num_trades,
                'Transaction Costs': f"${result.transaction_costs:.2f}"
            })

        summary_df = pd.DataFrame(summary_data)
        print("\n" + summary_df.to_string(index=False))

    def get_comparison_dataframe(self) -> pd.DataFrame:
        """
        Get detailed comparison DataFrame

        Returns:
        --------
        pd.DataFrame : Comparison metrics
        """
        comparison_data = []

        for model_name, result in self.results.items():
            comparison_data.append({
                'Model': model_name,
                'Total_PnL': result.total_pnl,
                'Gross_PnL': result.gross_pnl,
                'Net_PnL': result.net_pnl,
                'Sharpe_Ratio': result.sharpe_ratio,
                'Max_Drawdown': result.max_drawdown,
                'Win_Rate': result.win_rate,
                'Num_Trades': result.num_trades,
                'Transaction_Costs': result.transaction_costs,
                'Hedge_Costs': result.hedge_costs,
                'VaR_95': result.var_95
            })

        return pd.DataFrame(comparison_data)
